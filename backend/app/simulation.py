from fastapi import APIRouter, BackgroundTasks\nfrom .logger import logger\nfrom .alerts import send_email_alert, notify_agent\nimport time\nimport threading\nimport uuid\nimport sys\n\nrouter = APIRouter()\n\n# Global state for memory leak simulation\nmemory_hog = []\n\n# --- HANDLED ERRORS (~40%) ---\n\n@router.post(\"/simulate/memory_leak\")\ndef simulate_memory_leak(background_tasks: BackgroundTasks):\n    \"\"\"\n    Simulates a memory leak (Handled Exception).\n    \"\"\"\n    logger.warning(\"incident_simulated\", type=\"memory_leak\", status=\"started\")\n    \n    def leak():\n        for _ in range(10):\n            memory_hog.append(\" \" * 10 * 1024 * 1024) \n            time.sleep(1)\n        \n        try:\n            raise MemoryError(\"Out of memory: Kill process or sacrifice child\")\n        except Exception as e:\n            logger.exception(e)\n            \n        send_email_alert(\"High Memory Usage Detected\", \"Memory usage has crossed critical threshold.\")\n        notify_agent({\"incident\": \"memory_leak\", \"severity\": \"high\", \"details\": \"Memory usage spike detected.\"})\n\n    background_tasks.add_task(leak)\n    return {\"message\": \"Memory leak simulation started\"}\n\n@router.post(\"/simulate/memory_reset\")\ndef reset_memory():\n    global memory_hog\n    memory_hog = []\n    logger.info(\"memory_reset\", status=\"cleared\")\n    return {\"message\": \"Memory cleared\"}\n\n@router.post(\"/simulate/timeout\")\ndef simulate_timeout(duration: int = 30):\n    \"\"\"\n    Simulates an API timeout (Handled Exception).\
    \"\"\"\n    logger.warning(\"incident_simulated\", type=\"api_timeout\", duration=duration)\n    \n    time.sleep(duration)\n    \n    try:\n        raise TimeoutError(f\"Request timed out after {duration}s\")\n    except Exception as e:\n        logger.exception(e)\n    \n    notify_agent({\"incident\": \"api_timeout\", \"severity\": \"medium\", \"details\": f\"Endpoint took {duration}s to respond.\"})\n    return {\"message\": f\"Finished sleeping for {duration}s\"}\n\n@router.post(\"/simulate/disk_full\")\ndef simulate_disk_full():\n    \"\"\"\n    Simulates disk full (Handled Exception).\
    \"\"\"\n    logger.warning(\"incident_simulated\", type=\"disk_full\", status=\"simulated\")\n    \n    try:\n        raise OSError(28, \"No space left on device\", \"/data\")\n    except Exception as e:\n        logger.exception(e)\n    \n    send_email_alert(\"Disk Full Warning\", \"Disk usage at 99.9% on /data\")\n    notify_agent({\"incident\": \"disk_full\", \"severity\": \"critical\", \"details\": \"Disk usage critical.\"})\n    \n    return {\"message\": \"Disk full incident simulated\", \"metrics\": {\"disk_usage\": 99.9}}\n\n@router.post(\"/simulate/division_by_zero\")\ndef simulate_division_by_zero():\n    \"\"\"\n    Simulates division by zero (Handled Exception).\
    \"\"\"\n    try:\n        result = 1 / 0\n        return {\"result\": result}\n    except Exception as e:\n        logger.exception(e)\n        return {\"error\": \"Division by zero simulated\"}\n\n@router.post(\"/simulate/db_error\")\ndef simulate_db_error(duration: int = 30):\n    \"\"\"\n    Simulates DB error (Handled Exception).\
    \"\"\"\n    from .database import DB_FILE\n    import os\n    \n    logger.warning(\"incident_simulated\", type=\"db_connection_error\", duration=duration)\n    \n    original_path = DB_FILE\n    broken_path = DB_FILE + \".broken\"\n    \n    try:\n        if os.path.exists(original_path):\n            os.rename(original_path, broken_path)\n            logger.info(\"db_broken\", status=\"file_renamed\")\n            \n            def restore():\n                time.sleep(duration)\n                if os.path.exists(broken_path):\n                    os.rename(broken_path, original_path)\n                    logger.info(\"db_restored\", status=\"file_restored\")\n            \n            threading.Thread(target=restore).start()\n            notify_agent({\"incident\": \"db_connection_error\", \"severity\": \"critical\", \"details\": \"Database unreachable.\"})\n            return {\"message\": f\"DB error simulated for {duration}s\"}\n        else:\n            return {\"message\": \"DB file not found, maybe already broken?\"}\n    except Exception as e:\n        logger.exception(e)\n        return {\"error\": str(e)}\n\n\n# --- UNHANDLED ERRORS (~60%) ---\n\n@router.post(\"/simulate/unhandled/index_error\")\ndef simulate_index_error():\n    \"\"\"\n    Trigger an unhandled IndexError.\
    \"\"\"\n    logger.info(\"triggering_unhandled_error\", type=\"IndexError\")\n    my_list = [1, 2, 3]\n    if len(my_list) > 10:\n        return my_list[10]  # Crash\n    else:\n        return {\"error\": \"List index out of bounds\"}\n\n@router.post(\"/simulate/unhandled/key_error\")\ndef simulate_key_error():\n    \"\"\"\n    Trigger an unhandled KeyError.\
    \"\"\"\n    logger.info(\"triggering_unhandled_error\", type=\"KeyError\")\n    my_dict = {\"a\": 1}\n    return my_dict[\"b\"]  # Crash\n\n@router.post(\"/simulate/unhandled/type_error\")\ndef simulate_type_error():\n    \"\"\"\n    Trigger an unhandled TypeError.\
    \"\"\"\n    logger.info(\"triggering_unhandled_error\", type=\"TypeError\")\n    return 1 + \"2\"  # Crash\n\n@router.post(\"/simulate/unhandled/recursion_error\")\ndef simulate_recursion_error():\n    \"\"\"\n    Trigger an unhandled RecursionError.\
    \"\"\"\n    logger.info(\"triggering_unhandled_error\", type=\"RecursionError\")\n    def recursive():\n        return recursive()\n    return recursive()  # Crash\n\n@router.post(\"/simulate/unhandled/syntax_error\")\ndef simulate_syntax_error():\n    \"\"\"\n    Trigger an unhandled SyntaxError (via eval).\
    \"\"\"\n    logger.info(\"triggering_unhandled_error\", type=\"SyntaxError\")\n    eval(\"x =\")  # Crash\n\n\n# --- FIXABLE LOGIC BUGS (FOR AGENT TO SOLVE) ---\n\n@router.post(\"/simulate/bug/attribute_error\")\ndef simulate_attribute_error():\n    \"\"\"\n    Bug: Typo in method name.\
    \"\"\"\n    logger.info(\"triggering_bug\", type=\"AttributeError\")\n    my_list = []\n    # FIX: Should be .append()\n    my_list.appendd(\"item\") \n    return {\"message\": \"Should fail before this\"}\n\n@router.post(\"/simulate/bug/name_error\")\ndef simulate_name_error():\n    \"\"\"\n    Bug: Variable name mismatch.\
    \"\"\"\n    logger.info(\"triggering_bug\", type=\"NameError\")\n    user_name = \"Alice\"\n    # FIX: Should be user_name\n    return {\"user\": username} \n\n@router.post(\"/simulate/bug/value_error\")\ndef simulate_value_error():\n    \"\"\"\n    Bug: Invalid type cast logic.\
    \"\"\"\n    logger.info(\"triggering_bug\", type=\"ValueError\")\n    value = \"not_a_number\"\n    # FIX: Should validate input or catch error\n    return {\"number\": int(value)}\n\n@router.post(\"/simulate/bug/file_not_found\")\ndef simulate_file_not_found():\n    \"\"\"\n    Bug: Hardcoded wrong path.\
    \"\"\"\n    logger.info(\"triggering_bug\", type=\"FileNotFoundError\")\n    # FIX: Path should be valid or handled\n    with open(\"/tmp/non_existent_config.json\", \"r\") as f:\n        return f.read()\n\n\n@router.post(\"/simulate/traffic_gen\")\ndef simulate_traffic_gen(duration: int = 60, background_tasks: BackgroundTasks = None):\n    \"\"\"\n    Generates continuous traffic.\
    \"\"\"\n    import random\n    \n    logger.info(\"traffic_gen_started\", duration=duration, ratio=\"4:1\")\n    \n    def generate_traffic():\n        end_time = time.time() + duration\n        \n        while time.time() < end_time:\n            is_success = random.random() < 0.8\n            request_id = str(uuid.uuid4())\n            \n            if is_success:\n                action = random.choice([\"get_todos\", \"create_todo\", \"update_todo\"])\n                logger.debug(\n                    \"request_finished\", \n                    method=\"GET\" if action == \"get_todos\" else \"POST\",\n                    path=\"/todos\",\n                    status_code=200,\n                    process_time=random.uniform(0.01, 0.1), \n                    request_id=request_id,\n                    action=action\n                )\n            else:\n                # Simulate errors\n                error_type = random.choice([\"timeout\", \"db_error\", \"500_internal\"])\n                status_code = 504 if error_type == \"timeout\" else 500\n                \n                path = \"/todos\" if error_type == \"db_error\" else \"/simulate/timeout\"\n\n                # Log generic error to mimic application failure\n                # Note: traffic generator specific \'incidents\' are still logged here manually\n                # as they are \'simulated client side\' observations.\
                logger.error(\n                    error_type,\n                    details={\n                        \"method\": \"POST\",\n                        \"path\": path,\n                        \"status_code\": status_code,\n                        \"process_time\": random.uniform(0.1, 2.0),\n                        \"request_id\": request_id\n                    }\n                )\n            \n            time.sleep(random.uniform(0.1, 0.5))\n\n        logger.info(\"traffic_gen_finished\", duration=duration)\n\n    if background_tasks:\n        background_tasks.add_task(generate_traffic)\n    else:\n        threading.Thread(target=generate_traffic).start()\n        \n    return {\"message\": f\"Traffic generation started for {duration}s\"}\n