from fastapi import APIRouter, BackgroundTasks\nfrom .logger import logger\nfrom .alerts import send_email_alert, notify_agent\nimport time\nimport threading\nimport uuid\nimport sys\n\nrouter = APIRouter()\n\n# Global state for memory leak simulation\nmemory_hog = []\n\n# --- HANDLED ERRORS (~40%) ---\n\n@router.post(\"/simulate/memory_leak\")\ndef simulate_memory_leak(background_tasks: BackgroundTasks):\n    \"\"\"\n    Simulates a memory leak (Handled Exception).\n    \"\"\"\n    logger.warning(\"incident_simulated\", type=\"memory_leak\", status=\"started\")\n    \n    def leak():\n        for _ in range(10):\n            memory_hog.append(\" \" * 10 * 1024 * 1024) \n            time.sleep(1)\n        \n        try:\n            raise MemoryError(\"Out of memory: Kill process or sacrifice child\")\n        except Exception as e:\n            logger.exception(e)\n            \n        send_email_alert(\"High Memory Usage Detected\", \"Memory usage has crossed critical threshold.\")\n        notify_agent(severity=\"high\", error_message=\"Memory usage spike detected.\", incident_type=\"memory_leak\")\n\n    background_tasks.add_task(leak)\n    return {\"message\": \"Memory leak simulation started\"}\n\n@router.post(\"/simulate/memory_reset\")\ndef reset_memory():\n    global memory_hog\n    memory_hog = []\n    logger.info(\"memory_reset\", status=\"cleared\")\n    return {\"message\": \"Memory cleared\"}\n\n@router.post(\"/simulate/timeout\")\ndef simulate_timeout(duration: int = 30):\n    \"\"\"\n    Simulates an API timeout (Handled Exception).\n    \"\"\"\n    logger.warning(\"incident_simulated\", type=\"api_timeout\", duration=duration)\n    \n    time.sleep(duration)\n    \n    try:\n        raise TimeoutError(f\"Request timed out after {duration}s\")\n    except Exception as e:\n        logger.exception(e)\n    \n    notify_agent(severity=\"medium\", error_message=f\"Endpoint took {duration}s to respond.\", incident_type=\"api_timeout\")\n    return {\"message\": f\"Finished sleeping for {duration}s\"}\n\n@router.post(\"/simulate/disk_full\")\ndef simulate_disk_full():\n    \"\"\"\n    Simulates disk full (Handled Exception).\
    \"\"\"\n    logger.warning(\"incident_simulated\", type=\"disk_full\", status=\"simulated\")\n    \n    try:\n        raise OSError(28, \"No space left on device\", \"/data\")\n    except Exception as e:\n        logger.exception(e)\n    \n    send_email_alert(\"Disk Full Warning\", \"Disk usage at 99.9% on /data\")\n    notify_agent(severity=\"critical\", error_message=\"Disk usage critical.\", incident_type=\"disk_full\")\n    \n    return {\"message\": \"Disk full incident simulated\", \"metrics\": {\"disk_usage\": 99.9}}\n\n@router.post(\"/simulate/division_by_zero\")\ndef simulate_division_by_zero():\n    \"\"\"\
    Simulates division by zero (Handled Exception).\
    \"\"\"\
    try:\
        result = 0\n        if 0 != 0:\n            result = 1 / 0\
        return {\"result\": result}\
    except Exception as e:\
        logger.exception(e)\
        notify_agent(severity=\"high\", error_message=str(e), incident_type=\"division_by_zero\")\
        return {\"error\": \"Division by zero simulated\"}\
\n@router.post(\"/simulate/db_error\")\ndef simulate_db_error(duration: int = 30):\n    \"\"\"\n    Simulates DB error (Handled Exception).\n    \"\"\"\n    from .database import DB_FILE\n    import os\n    \n    logger.warning(\"incident_simulated\", type=\"db_connection_error\", duration=duration)\n    \n    original_path = DB_FILE\n    broken_path = DB_FILE + \".broken\"\n    \n    try:\n        if os.path.exists(original_path):\n            os.rename(original_path, broken_path)\n            logger.info(\"db_broken\", status=\"file_renamed\")\n            \n            def restore():\n                time.sleep(duration)\n                if os.path.exists(broken_path):\n                    os.rename(broken_path, original_path)\n                    logger.info(\"db_restored\", status=\"file_restored\")\n            \n            threading.Thread(target=restore).start()\n            notify_agent(severity=\"critical\", error_message=\"Database unreachable.\", incident_type=\"db_connection_error\")\n            return {\"message\": f\"DB error simulated for {duration}s\"}\n        else:\n            return {\"message\": \"DB file not found, maybe already broken?\"}\n    except Exception as e:\n        logger.exception(e)\n        return {\"error\": str(e)}\n\n\n# --- UNHANDLED ERRORS (~60%) ---\n\n@router.post(\"/simulate/unhandled/index_error\")\ndef simulate_index_error():\n    \"\"\"\n    Trigger an unhandled IndexError.\n    \"\"\"\n    logger.info(\"triggering_unhandled_error\", type=\"IndexError\")\n    my_list = [1, 2, 3]\n    return my_list[10]  # Crash\n\n@router.post(\"/simulate/unhandled/key_error\")\ndef simulate_key_error():\n    \"\"\"\n    Trigger an unhandled KeyError.\n    \"\"\"\n    logger.info(\"triggering_unhandled_error\", type=\"KeyError\")\n    my_dict = {\"a\": 1}\n    return my_dict[\"b\"]  # Crash\n\n@router.post(\"/simulate/unhandled/type_error\")\ndef simulate_type_error():\n    \"\"\"\n    Trigger an unhandled TypeError.\n    \"\"\"\n    logger.info(\"triggering_unhandled_error\", type=\"TypeError\")\n    return 1 + \"2\"  # Crash\n\n@router.post(\"/simulate/unhandled/recursion_error\")\ndef simulate_recursion_error():\n    \"\"\"\n    Trigger an unhandled RecursionError.\n    \"\"\"\n    logger.info(\"triggering_unhandled_error\", type=\"RecursionError\")\n    def recursive():\n        return recursive()\n    return recursive()  # Crash\n\n@router.post(\"/simulate/unhandled/syntax_error\")\ndef simulate_syntax_error():\n    \"\"\"\n    Trigger an unhandled SyntaxError (via eval).\n    \"\"\"\n    logger.info(\"triggering_unhandled_error\", type=\"SyntaxError\")\n    eval(\"x =\")  # Crash\n\n\n# --- FIXABLE LOGIC BUGS (REALISTIC FEATURES) ---\n\n@router.post(\"/simulate/bug/attribute_error\")\ndef feature_add_to_cart():\n    \"\"\"\n    Feature: Add item to shopping cart.\n    Bug: AttributeError (Typo in method name).\
    \"\"\"\n    logger.info(\"accessing_feature\", feature=\"shopping_cart\", action=\"add\")\n    cart = [\"apple\", \"orange\"]\n    # FIX: Change \'appendd\' to \'append\'\n    cart.appendd(\"banana\") \n    return {\"status\": \"success\", \"cart\": cart}\n\n@router.post(\"/simulate/bug/name_error\")\ndef feature_get_user_profile():\n    \"\"\"\n    Feature: User Profile.\n    Bug: NameError (Variable name mismatch).\n    \"\"\"\n    logger.info(\"accessing_feature\", feature=\"user_profile\", action=\"get\")\n    user_name = \"Alice\"\n    email = \"alice@example.com\"\n    # FIX: Change \'username\' to \'user_name\'\n    return {\"user\": username, \"email\": email} \n\n@router.post(\"/simulate/bug/value_error\")\ndef feature_process_payment():\n    \"\"\"\n    Feature: Process payment amount.\n    Bug: ValueError (Invalid type cast).\n    \"\"\"\n    logger.info(\"accessing_feature\", feature=\"payment\", action=\"process\")\n    amount_str = \"$50\" # Received from input\n    # FIX: Strip \'$\' before converting: int(amount_str.replace(\'$\', \'\'))\n    amount = int(amount_str)\n    return {\"status\": \"processed\", \"amount\": amount}\n\n@router.post(\"/simulate/bug/file_not_found\")\ndef feature_load_config():\n    \"\"\"\n    Feature: Load Application Config.\n    Bug: FileNotFoundError (Wrong path).\n    \"\"\"\n    logger.info(\"accessing_feature\", feature=\"config\", action=\"load\")\n    # FIX: Handle missing file or point to a real file (e.g., match standard config)\n    # For simulation, getting this to work might mean mocking the return or creating the file.\n    with open(\"config/app_settings.json\", \"r\") as f:\n        return {\"config\": f.read()}\n\n@router.post(\"/simulate/bug/unbound_local\")\ndef feature_increment_counter():\n    \"\"\"\n    Feature: Visit Counter.\n    Bug: UnboundLocalError (Scope issue).\
    \"\"\"\n    logger.info(\"accessing_feature\", feature=\"counter\", action=\"increment\")\n    count = 100\n    def update_count():\n        # FIX: Add \'nonlocal count\'\n        count += 1\n        return count\n    new_count = update_count()\n    return {\"visits\": new_count}\n\n@router.post(\"/simulate/bug/module_not_found\")\ndef feature_load_plugin():\n    \"\"\"\n    Feature: Load Export Plugin.\n    Bug: ModuleNotFoundError.\n    \"\"\"\n    logger.info(\"accessing_feature\", feature=\"plugins\", action=\"load_export\")\n    # FIX: Remove bad import or mock it\n    import pdf_export_plugin \n    return {\"status\": \"plugin_loaded\", \"plugin\": \"pdf_export\"}\n\n@router.post(\"/simulate/bug/json_decode\")\ndef feature_parse_webhook():\n    \"\"\"\n    Feature: Parse Webhook Payload.\n    Bug: JSONDecodeError.\
    \"\"\"\n    import json\n    logger.info(\"accessing_feature\", feature=\"webhook\", action=\"parse\")\n    # Simulating a payload execution\n    raw_payload = \"{\'event\': \'order_created\'}\" # Single quotes are invalid JSON\n    # FIX: Use double quotes: \'{\"event\": \"order_created\"}\'\n    data = json.loads(raw_payload)\n    return {\"parsed\": True, \"data\": data}\n\n@router.post(\"/simulate/bug/permission_error\")\ndef feature_read_system_stats():\n    \"\"\"\n    Feature: System Health Stats.\n    Bug: PermissionError.\n    \"\"\"\n    logger.info(\"accessing_feature\", feature=\"system_stats\", action=\"read\")\n    # FIX: Read a user-accessible file (e.g., /proc/loadavg on Linux or just a mock)\n    # /etc/shadow is root only\n    with open(\"/etc/shadow\", \"r\") as f:\n        return {\"stats\": f.read()}\n\n\n# --- ADDITIONAL UNHANDLED ERRORS ---\n\n@router.post(\"/simulate/unhandled/not_implemented\")\ndef simulate_not_implemented():\n    \"\"\"\n    Trigger NotImplementedError.\n    \"\"\"\n    logger.info(\"triggering_unhandled_error\", type=\"NotImplementedError\")\n    raise NotImplementedError(\"This feature is coming soon\")\n\n@router.post(\"/simulate/unhandled/assertion\")\ndef simulate_assertion():\n    \"\"\"\n    Trigger AssertionError.\
    \"\"\"\n    logger.info(\"triggering_unhandled_error\", type=\"AssertionError\")\n    assert 1 == 2, \"Math is broken\"\n\n@router.post(\"/simulate/unhandled/import_error\")\ndef simulate_import_error():\n    \"\"\"\n    Trigger ImportError.\n    \"\"\"\n    logger.info(\"triggering_unhandled_error\", type=\"ImportError\")\n    raise ImportError(\"Failed to import required module \'antigravity\'\")\n\n@router.post(\"/simulate/unhandled/unicode\")\ndef simulate_unicode_error():\n    \"\"\"\n    Trigger UnicodeDecodeError.\n    \"\"\"\n    logger.info(\"triggering_unhandled_error\", type=\"UnicodeDecodeError\")\n    b\'\\x80\'.decode(\"utf-8\")\n\n@router.post(\"/simulate/unhandled/floating_point\")\ndef simulate_floating_point():\n    \"\"\"\n    Trigger FloatingPointError.\n    \"\"\"\n    # Note: Python usually handles floats graciously, forcing an error for sim\n    logger.info(\"triggering_unhandled_error\", type=\"FloatingPointError\")\n    import math\n    math.exp(1000) # Overflow -> usually OverflowError, close enough\n\n\n# --- ADDITIONAL HANDLED INCIDENTS ---\n\n@router.post(\"/simulate/connection_refused\")\ndef simulate_connection_refused():\n    \"\"\"\n    Simulates ConnectionRefusedError (Handled).\
    \"\"\"\n    import socket\n    logger.warning(\"incident_simulated\", type=\"connection_refused\")\n    try:\n        s = socket.socket()\n        s.connect((\"127.0.0.1\", 9999)) # Port 9999 likely closed\n    except Exception as e:\n        logger.exception(e)\n    return {\"message\": \"Connection refused simulated\"}\n\n@router.post(\"/simulate/service_unavailable\")\ndef simulate_service_unavailable():\n    \"\"\"\n    Simulates 503 Service Unavailable behavior (Handled).\
    \"\"\"\n    from fastapi import HTTPException\n    logger.warning(\"incident_simulated\", type=\"service_unavailable\")\n    try:\n        raise HTTPException(status_code=503, detail=\"Upstream service down\")\n    except Exception as e:\n        logger.exception(e)\n        raise e # Re-raise to actually return 503\n\n@router.post(\"/simulate/auth_failure\")\ndef simulate_auth_failure():\n    \"\"\"\n    Simulates 401 Auth Failure logic error (Handled).\
    \"\"\"\n    logger.warning(\"incident_simulated\", type=\"auth_failure\")\n    try:\n        raise PermissionError(\"Invalid API Key provided\")\n    except Exception as e:\n        logger.exception(e)\n    return {\"error\": \"Authentication failed\"}\n\n@router.post(\"/simulate/read_timeout\")\ndef simulate_read_timeout():\n    \"\"\"\n    Simulates Read Timeout (Handled).\
    \"\"\"\n    logger.warning(\"incident_simulated\", type=\"read_timeout\")\n    try:\n        raise TimeoutError(\"Read operation timed out after 5000ms\")\n    except Exception as e:\n        logger.exception(e)\n    return {\"error\": \"Read timeout\"}\n\n@router.post(\"/simulate/cache_explosion\")\ndef simulate_cache_explosion():\n    \"\"\"\n    Simulates Cache Explosion (Handled).\
    \"\"\"\n    logger.warning(\"incident_simulated\", type=\"cache_explosion\")\n    try:\n        # Simulate generating too many keys\n        raise MemoryError(\"Redis cache full: 1000000 keys eviction failed\")\n    except Exception as e:\n        logger.exception(e)\n    return {\"error\": \"Cache overflow\"}\n\n\n@router.post(\"/simulate/traffic_gen\")\ndef simulate_traffic_gen(duration: int = 60, background_tasks: BackgroundTasks = None):\n    \"\"\"\n    Generates continuous traffic.\
    \"\"\"\n    import random\n    \n    logger.info(\"traffic_gen_started\", duration=duration, ratio=\"4:1\")\n    \n    def generate_traffic():\n        end_time = time.time() + duration\
        \n        while time.time() < end_time:\
            is_success = random.random() < 0.8\
            request_id = str(uuid.uuid4())\
            \n            if is_success:\n                action = random.choice([\"get_todos\", \"create_todo\", \"update_todo\"])\
                logger.debug(\
                    \"request_finished\", \
                    method=\"GET\" if action == \"get_todos\" else \"POST\",\
                    path=\"/todos\",\
                    status_code=200,\
                    process_time=random.uniform(0.01, 0.1), \
                    request_id=request_id,\
                    action=action\
                )\n            else:\n                # Simulate errors\
                error_type = random.choice([\"timeout\", \"db_error\", \"500_internal\"])\
                status_code = 504 if error_type == \"timeout\" else 500\
                \
                path = \"/todos\" if error_type == \"db_error\" else \"/simulate/timeout\"\
\n                # Log generic error to mimic application failure\
                # Note: traffic generator specific \'incidents\' are still logged here manually\
                # as they are \'simulated client side\' observations.\
                logger.error(\
                    error_type,\
                    details={\
                        \"method\": \"POST\",\
                        \"path\": path,\
                        \"status_code\": status_code,\
                        \"process_time\": random.uniform(0.1, 2.0),\
                        \"request_id\": request_id\
                    }\
                )\
            \n            time.sleep(random.uniform(0.1, 0.5))\
\n        logger.info(\"traffic_gen_finished\", duration=duration)\
\n    if background_tasks:\
        background_tasks.add_task(generate_traffic)\
    else:\
        threading.Thread(target=generate_traffic).start()\
        \n    return {\"message\": f\"Traffic generation started for {duration}s\"}\n